<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ë§ˆë¹„ë…¸ê¸° ê½ƒê¸¸ ê¸¸ë“œíŒŸ</title>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; padding: 20px; margin: 0; }
    form, select, input, button { width: 100%; max-width: 500px; margin: 5px auto; display: block; }
    .dungeon-section { margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px; }
    .role-dps { background-color: #FFD1B3; padding: 2px 5px; border-radius: 4px; }
    .role-heal { background-color: #C2F0C2; padding: 2px 5px; border-radius: 4px; }
    .role-tank { background-color: #C2E0FF; padding: 2px 5px; border-radius: 4px; }
    .party-block { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
    .party-block.fixed { background: #f9f9f9; border: 1px solid #ddd; padding: 5px; }
    ul { padding-left: 20px; }
    li { margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
    .inline-btn { display: inline-block; width: auto; font-size: 0.8em; padding: 4px 6px; margin-left: 5px; background: #eee; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
    .inline-input { display: inline-block; width: 120px; font-size: 0.8em; padding: 4px; margin-left: 5px; }
    .match-buttons { display: flex; gap: 10px; margin-top: 10px; justify-content: center; flex-wrap: wrap; }
    .match-buttons button { flex: 1; min-width: 120px; padding: 6px 10px; font-size: 0.9em; }
    @media screen and (max-width: 600px) { input, select, button { width: 100%; margin: 5px 0; } .match-buttons { flex-direction: column; } }
    #weekday-checkboxes {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-start;
    }
  </style>
</head>
<body>
  <h1 style="text-align:center">ë§ˆë¹„ë…¸ê¸° ê½ƒê¸¸ ê¸¸ë“œíŒŸ</h1>
  <form id="partyForm">
    <label>ë˜ì „:</label>
    <select id="dungeon"><option value="ì–´ë¹„ìŠ¤">ì–´ë¹„ìŠ¤</option><option value="ë ˆì´ë“œ">ë ˆì´ë“œ</option></select>
    <label>ë‚œì´ë„:</label>
    <select id="difficulty"></select>
    <label>ë‹‰ë„¤ì„:</label>
    <input type="text" id="nickname" required>
    <label>ì§ì—…:</label>
    <input type="text" id="job" required>
    <label>ì—­í• :</label>
    <select id="role"><option value="ë”œëŸ¬">ë”œëŸ¬</option><option value="íëŸ¬">íëŸ¬</option><option value="íƒ±ì»¤">íƒ±ì»¤</option></select>
    <label>ì „íˆ¬ë ¥/ê°€ëŠ¥ì‹œê°„ (ì„ íƒ):</label>
    <input type="text" id="note" placeholder="ì—†ìœ¼ë©´ ë¹„ì›Œë‘ì„¸ìš”">
    <label>í¬ë§ ìš”ì¼:</label>
    <div id="weekday-checkboxes">
      <label><input type="checkbox" name="days" value="ì›”">ì›”</label>
      <label><input type="checkbox" name="days" value="í™”">í™”</label>
      <label><input type="checkbox" name="days" value="ìˆ˜">ìˆ˜</label>
      <label><input type="checkbox" name="days" value="ëª©">ëª©</label>
      <label><input type="checkbox" name="days" value="ê¸ˆ">ê¸ˆ</label>
      <label><input type="checkbox" name="days" value="í† ">í† </label>
      <label><input type="checkbox" name="days" value="ì¼">ì¼</label>
    </div>
    <button type="submit">ì‹ ì²­</button>
  </form>
  <div id="dungeonSections"></div>
  <script>
    const firebaseConfig = { apiKey: "AIzaSyColXLlJbXM6x97A4j1ME8QWNKTheAccFM", authDomain: "mabinogim-flowerroad-party.firebaseapp.com", databaseURL: "https://mabinogim-flowerroad-party-default-rtdb.firebaseio.com", projectId: "mabinogim-flowerroad-party", storageBucket: "mabinogim-flowerroad-party.appspot.com", messagingSenderId: "1051963693734", appId: "1:1051963693734:web:c264607ec4ec562147267" };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    // --- Drag & Drop Helpers ---
    function dragStartApplicant(e, key, id) {
      e.dataTransfer.setData('application/json', JSON.stringify({type:'applicant', key, id}));
    }
    function dragStartMember(e, key, partyIdx, memberIdx) {
      e.dataTransfer.setData('application/json', JSON.stringify({type:'member', key, partyIdx, memberIdx}));
    }
    function allowDrop(e) {
      e.preventDefault();
    }
    
    function dropOnMember(e, key, partyIdx, memberIdx) {
      e.preventDefault();
      const data = JSON.parse(e.dataTransfer.getData('application/json'));
      if (data.type !== 'applicant') return;
      const group = matchedParties[key][partyIdx];
      const applicantId = data.id;
      db.ref(`parties/${key}/${applicantId}`).once('value').then(snap => {
        const newMember = {...snap.val(), days: snap.val().days || [], id: snap.key};
        const oldMember = group[memberIdx];
        // Check overlap with existing members
        const others = group.filter((_, idx) => idx !== memberIdx);
        for (const m of others) {
          const common = m.days.filter(d => newMember.days.includes(d));
          if (common.length === 0) {
            alert("ê°€ëŠ¥í•œ ìš”ì¼ì´ ì—†ìŠµë‹ˆë‹¤.");
            return; // abort swap
          }
        }
        // Perform swap
        group[memberIdx] = newMember;
        db.ref(`parties/${key}/${oldMember.id}`).set(oldMember);
        db.ref(`parties/${key}/${newMember.id}`).remove();
        return db.ref(`matchedParties/${key}`).set(matchedParties[key]);
      }).catch(console.error);
    }

    function dropOnApplicantList(e, key) {
      e.preventDefault();
      const data = JSON.parse(e.dataTransfer.getData('application/json'));
      if (data.type !== 'member') return;
      const {partyIdx, memberIdx} = data;
      const group = matchedParties[key][partyIdx];
      const member = group.splice(memberIdx, 1)[0];
      db.ref(`parties/${key}/${member.id}`).set(member)
        .then(() => db.ref(`matchedParties/${key}`).set(matchedParties[key]))
        .catch(console.error);
    }
    // ----------------------------


    const dungeonConfigs = { ì–´ë¹„ìŠ¤: { difficulties: ['ì…ë¬¸','ì–´ë ¤ì›€','ë§¤ìš°ì–´ë ¤ì›€','ì§€ì˜¥1','ì§€ì˜¥2'], partySize: 4 }, ë ˆì´ë“œ: { difficulties: ['ì…ë¬¸','ì–´ë ¤ì›€'], partySize: 8 } };
    const matchedParties = {};
    const pinnedParties = {};

    const form = document.getElementById('partyForm'),
          dungeonSelect = document.getElementById('dungeon'),
          difficultySelect = document.getElementById('difficulty'),
          nicknameInput = document.getElementById('nickname'),
          jobInput = document.getElementById('job'),
          roleSelect = document.getElementById('role'),
          noteInput = document.getElementById('note'),
          sectionsContainer = document.getElementById('dungeonSections');

    function updateDifficultyOptions() {
      const cfg = dungeonConfigs[dungeonSelect.value];
      difficultySelect.innerHTML = '';
      cfg.difficulties.forEach(d => { const o = document.createElement('option'); o.value = d; o.textContent = d; difficultySelect.appendChild(o); });
      if (dungeonSelect.value === 'ì–´ë¹„ìŠ¤') {
        difficultySelect.value = 'ì§€ì˜¥2';
      } else if (dungeonSelect.value === 'ë ˆì´ë“œ') {
        difficultySelect.value = 'ì–´ë ¤ì›€';
      }
    }
    dungeonSelect.addEventListener('change', updateDifficultyOptions);
    updateDifficultyOptions();

    function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }
    function normalize(v,id) { return { id, nickname: v.nickname !== undefined ? v.nickname : v.name, job: v.job, role: v.role, note: v.note, days: v.days || [] }; }

    form.addEventListener('submit', e => {
      e.preventDefault();
      const selectedDays = Array.from(document.querySelectorAll('input[name="days"]:checked')).map(cb => cb.value);
      if (selectedDays.length === 0) {
        alert('í¬ë§ ìš”ì¼ì„ ì„ íƒí•˜ì„¸ìš”.');
        return;
      }
      const key = `${dungeonSelect.value}_${difficultySelect.value}`;
      // ê³ ì •ëœ íŒŒí‹° ë©¤ë²„ë„ ì¬ì‹ ì²­ ê°€ëŠ¥í•˜ë„ë¡ ê¸°ì¡´ ì²´í¬ ì œê±°
      if (!nicknameInput.value.trim() || !jobInput.value.trim()) return;
      const ref = db.ref(`parties/${key}`).push();
      ref.set({ nickname: nicknameInput.value.trim(), job: jobInput.value.trim(), role: roleSelect.value, note: noteInput.value.trim(), days: selectedDays, id: ref.key });
      form.reset(); updateDifficultyOptions();
    });

    function renderSection(key,list) {
      let sec = document.getElementById(`section-${key}`);
      if (!sec) {
        sec = document.createElement('div'); sec.id = `section-${key}`; sec.className = 'dungeon-section';
        sec.innerHTML = `
          <h2>${key.replace('_',' - ')} (<span id="${key}-count">0</span>ëª… ì‹ ì²­)</h2>
          <ul id="${key}-list" ondragover="allowDrop(event)" ondrop="dropOnApplicantList(event, \'${key}\')" ></ul>
          <div class="match-buttons"><button onclick="match('${key}', ${dungeonConfigs[key.split('_')[0]].partySize})">íŒŒí‹° ìë™ ë§¤ì¹­</button></div>
          <div id="${key}-matched"></div>
        `;
        sectionsContainer.appendChild(sec);
      }
      const ul = document.getElementById(`${key}-list`), cnt = document.getElementById(`${key}-count`);
      const excludedIds = new Set((pinnedParties[key]||[]).flatMap(obj => obj.members).map(m => m.id));
      const remaining = list.filter(p => !excludedIds.has(p.id));
      // ê°™ì€ ë‹‰ë„¤ì„ì€ í•œ ëª…ìœ¼ë¡œ ê³„ì‚°í•˜ë„ë¡
      const uniqueCount = new Set(remaining.map(p => p.nickname)).size;
      cnt.textContent = uniqueCount;
      ul.innerHTML = '';
      remaining.forEach((p,i) => {
        const daysStr = p.days && p.days.length ? ` [${p.days.join(',')}]` : '';
        const noteStr = p.note ? ` - [${p.note}]` : '';
        const li = document.createElement('li');
        li.draggable = true;
        li.ondragstart = e => dragStartApplicant(e, key, p.id);
        li.innerHTML = `${i+1}. <span class="role-${p.role==='ë”œëŸ¬'?'dps':p.role==='íëŸ¬'?'heal':'tank'}">${p.nickname} (${p.job}) ${p.role}${daysStr}${noteStr}</span><button class="inline-btn" onclick="removeApplicant('${key}','${p.id}')">âŒ</button>`;
        ul.appendChild(li);
      });
    }
    window.renderSection = renderSection;
    function removeApplicant(key,id){ db.ref(`parties/${key}/${id}`).remove(); } window.removeApplicant = removeApplicant;

    function renderMatched(key) {
      const box = document.getElementById(`${key}-matched`);
      const pinned = pinnedParties[key] || [];
      let unmatched = (matchedParties[key] || []).filter(group => {
        return !pinned.some(pObj => {
          const pinnedIds = new Set(pObj.members.map(m => m.id));
          const groupIds = new Set(group.map(m => m.id));
          if (pinnedIds.size !== groupIds.size) return false;
          for (const id of pinnedIds) if (!groupIds.has(id)) return false;
          return true;
        });
      });
      if (pinned.length === 0 && unmatched.length === 0) {
        box.innerHTML = '<p>ë§¤ì¹­ëœ íŒŒí‹° ì—†ìŒ</p>';
        return;
      }
      let html = '';
      pinned.forEach((partyObj, i) => {
        // calculate common days for pinned group
        const allDays = partyObj.members.map(m => new Set(m.days));
        const commonDaysSet = allDays.reduce((a, b) => new Set([...a].filter(x => b.has(x))), allDays[0] || new Set());
        const commonDaysArr = [...commonDaysSet];
        const commonDaysDisplay = commonDaysArr.length ? ` [${commonDaysArr.join(',')}]` : '';
        const members = partyObj.members.map(p => `<span class="role-${p.role==='ë”œëŸ¬'?'dps':p.role==='íëŸ¬'?'heal':'tank'}">${p.nickname} (${p.job})</span>` + (p.note ? ` - [${p.note}]` : '')).join(', ');
        const memo = partyObj.memo || '';
        html += `<div class="party-block fixed"><strong>ğŸ”’ ê³ ì • íŒŒí‹° ${i+1}</strong>${commonDaysDisplay}: ${members}` +
                `<input id="${key}-memo-${i}" type="text" value="${memo}" placeholder="ì•½ì†ì‹œê°„" class="inline-input"/>` +
                `<button class="inline-btn" onclick="saveMemo('${key}',${i})">ì €ì¥</button>` +
                `<button class="inline-btn" onclick="unpinParty('${key}',${i})">ê³ ì •í•´ì œ</button><button class="inline-btn" onclick="deletePinnedParty('${key}',${i})">ì™„ì „ì‚­ì œ</button></div>`;
      });
      
      unmatched.forEach((party, i) => {
        const allDays = party.map(m => new Set(m.days));
        const commonDaysSet = allDays.reduce((a, b) => new Set([...a].filter(x => b.has(x))), allDays[0] || new Set());
        const commonDaysArr = [...commonDaysSet];
        const commonDaysDisplay = commonDaysArr.length ? ` [${commonDaysArr.join(',')}]` : '';
        html += `<div class="party-block">íŒŒí‹° ${i+1}${commonDaysDisplay}: `;
        party.forEach((m, mi) => {
          html += `<span class="member-item role-${m.role==='ë”œëŸ¬'?'dps':m.role==='íëŸ¬'?'heal':'tank'}" draggable="true" ondragstart="dragStartMember(event,'${key}',${i},${mi})" ondragover="allowDrop(event)" ondrop="dropOnMember(event,'${key}',${i},${mi})">${m.nickname} (${m.job})${m.note? ' - ['+m.note+']':''}</span>`;
        });
        html += `<button class="inline-btn" onclick="pinParty('${key}',${i})">ê³ ì •</button><button class="inline-btn" onclick="deleteParty('${key}',${i})">âŒ</button></div>`;
      });
box.innerHTML = html;
    }
    window.renderMatched = renderMatched;

    function saveMemo(key, idx) {
      const input = document.getElementById(`${key}-memo-${idx}`);
      const val = input.value.trim();
      pinnedParties[key][idx].memo = val;
      db.ref(`pinnedParties/${key}`).set(pinnedParties[key]);
      alert('ë©”ëª¨ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
    window.saveMemo = saveMemo;

    function pinParty(key,idx) {
      if (!pinnedParties[key]) pinnedParties[key] = [];
      const grp = matchedParties[key].splice(idx,1)[0];
      pinnedParties[key].push({ members: grp, memo: '' });
      db.ref(`matchedParties/${key}`).set(matchedParties[key]);
      db.ref(`pinnedParties/${key}`).set(pinnedParties[key]);
      renderMatched(key);
    }
    window.pinParty = pinParty;

    function unpinParty(key,idx) {
      const entry = pinnedParties[key].splice(idx,1)[0];
      const grp = entry.members;
      matchedParties[key].unshift(grp);
      db.ref(`matchedParties/${key}`).set(matchedParties[key]);
      db.ref(`pinnedParties/${key}`).set(pinnedParties[key]);
      renderMatched(key);
    }
    window.unpinParty = unpinParty;

    // ì™„ì „ì‚­ì œ: ê³ ì • íŒŒí‹°ë¥¼ ì‚­ì œí•˜ê³  ì‹ ì²­ì ë¦¬ìŠ¤íŠ¸ë¡œ ë³µê·€í•˜ì§€ ì•ŠìŒ
    function deletePinnedParty(key, idx) {
      pinnedParties[key].splice(idx, 1);
      db.ref(`pinnedParties/${key}`).set(pinnedParties[key]);
      renderMatched(key);
    }
    window.deletePinnedParty = deletePinnedParty;

    function deleteParty(key,idx) {
      const p = matchedParties[key].splice(idx,1)[0];
      p.forEach(m => db.ref(`parties/${key}/${m.id}`).set(m));
      db.ref(`matchedParties/${key}`).set(matchedParties[key]);
      renderMatched(key);
    }
    window.deleteParty = deleteParty;

    function match(key,size) {
      const partiesRef = db.ref(`parties/${key}`), matchedRef = db.ref(`matchedParties/${key}`);
      if (matchedParties[key]) matchedParties[key].flat().forEach(m => db.ref(`parties/${key}/${m.id}`).set(m));
      matchedRef.set([])
        .then(() => partiesRef.once('value'))
        .then(snap => {
          let mems = snap.val() ? Object.entries(snap.val()).map(([id,v]) => normalize(v,id)) : [];
          const pinnedIds = new Set((pinnedParties[key] || []).flatMap(obj => obj.members).map(m => m.id));
          mems = mems.filter(p => !pinnedIds.has(p.id));
          shuffle(mems);
          const newMatched = [];
          while (mems.length >= size) {
            const group = [];
            const used = new Set();
            let groupDays = null;
            for (const p of mems) {
              if (group.length === size) break;
              if (used.has(p.nickname)) continue;
              if (group.length === 0) {
                // ì²« ë©¤ë²„ì— ëŒ€í•´ ìš”ì¼ ì§‘í•© ì´ˆê¸°í™”
                group.push(p);
                used.add(p.nickname);
                groupDays = new Set(p.days);
              } else {
                // ê·¸ë£¹ ë‚´ ê³µí†µ ìš”ì¼ ì—¬ë¶€ í™•ì¸
                const pDaysSet = new Set(p.days);
                const intersection = new Set([...groupDays].filter(d => pDaysSet.has(d)));
                if (intersection.size > 0) {
                  group.push(p);
                  used.add(p.nickname);
                  groupDays = intersection;
                }
              }
            }
            // ê³µí†µ ìš”ì¼ì´ í•˜ë‚˜ë¼ë„ ì—†ìœ¼ë©´ ê·¸ë£¹ ë§¤ì¹­ ì¤‘ë‹¨
            if (group.length < size) break;
            newMatched.push(group);
            mems = mems.filter(p => !used.has(p.nickname));
          
          }
          const finalMatched = newMatched.filter(group => {
            const groupIds = new Set(group.map(m => m.id));
            return !(pinnedParties[key] || []).some(pinnedObj => {
              const pinnedIds = new Set(pinnedObj.members.map(m => m.id));
              if (pinnedIds.size !== groupIds.size) return false;
              for (const id of pinnedIds) if (!groupIds.has(id)) return false;
              return true;
            });
          });
          matchedParties[key] = finalMatched;
          return matchedRef.set(finalMatched);
        })
        .then(() => partiesRef.once('value'))
        .then(() => Promise.all((matchedParties[key] || []).flat().map(p => db.ref(`parties/${key}/${p.id}`).remove())))
        .then(() => renderMatched(key))
        .catch(err => console.error(err));
    }
    window.match = match;

    Object.keys(dungeonConfigs).forEach(d => dungeonConfigs[d].difficulties.forEach(diff => {
      const k = `${d}_${diff}`;
      db.ref(`parties/${k}`).on('value', snap => {
        const list = snap.val() ? Object.entries(snap.val()).map(([id,v]) => normalize(v,id)) : [];
        renderSection(k, list);
      });
      db.ref(`matchedParties/${k}`).on('value', snap => {
        matchedParties[k] = snap.val() || [];
        renderMatched(k);
      });
      db.ref(`pinnedParties/${k}`).on('value', snap => {
        let data = snap.val() || [];
        data = data.map(entry => entry.members ? entry : { members: entry, memo: '' });
        pinnedParties[k] = data;
        renderMatched(k);
      });
    }));
  </script>
</body>
</html>
