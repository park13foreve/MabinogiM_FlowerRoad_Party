<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>마비노기 꽃길 길드팟</title>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; padding: 20px; margin: 0; }
    form, select, input, button { width: 100%; max-width: 500px; margin: 5px auto; display: block; }
    .dungeon-section { margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px; }
    .role-dps { background-color: #FFD1B3; padding: 2px 5px; border-radius: 4px; }
    .role-heal { background-color: #C2F0C2; padding: 2px 5px; border-radius: 4px; }
    .role-tank { background-color: #C2E0FF; padding: 2px 5px; border-radius: 4px; }
    .party-block { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
    .fixed .party-block { background: #f9f9f9; border: 1px solid #ddd; padding: 5px; }
    ul { padding-left: 20px; }
    li { margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
    .inline-btn { font-size: 0.8em; padding: 4px 6px; margin-left: 5px; background: #eee; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
    .match-buttons { display: flex; gap: 10px; margin-top: 10px; justify-content: center; flex-wrap: wrap; }
    .match-buttons button { flex: 1; min-width: 120px; padding: 6px 10px; font-size: 0.9em; }
    @media screen and (max-width: 600px) { input, select, button { width: 100%; margin: 5px 0; } .match-buttons { flex-direction: column; } }
  </style>
</head>
<body>
  <h1 style="text-align:center">마비노기 꽃길 길드팟</h1>
  <form id="partyForm">
    <label>던전:</label>
    <select id="dungeon"><option value="어비스">어비스</option><option value="레이드">레이드</option></select>
    <label>난이도:</label>
    <select id="difficulty"></select>
    <label>닉네임:</label>
    <input type="text" id="nickname" required>
    <label>직업:</label>
    <input type="text" id="job" required>
    <label>역할:</label>
    <select id="role"><option value="딜러">딜러</option><option value="힐러">힐러</option><option value="탱커">탱커</option></select>
    <label>특이사항 (선택):</label>
    <input type="text" id="note" placeholder="없으면 비워두세요">
    <button type="submit">신청</button>
  </form>
  <div id="dungeonSections"></div>
  <script>
    const firebaseConfig = { apiKey: "AIzaSyColXLlJbXM6x97A4j1ME8QWNKTheAccFM", authDomain: "mabinogim-flowerroad-party.firebaseapp.com", databaseURL: "https://mabinogim-flowerroad-party-default-rtdb.firebaseio.com", projectId: "mabinogim-flowerroad-party", storageBucket: "mabinogim-flowerroad-party.appspot.com", messagingSenderId: "1051963693734", appId: "1:1051963693734:web:c264607ec4ec562147267" };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    const dungeonConfigs = { 어비스: { difficulties: ['입문','어려움','매우어려움'], partySize: 4 }, 레이드: { difficulties: ['입문'], partySize: 8 } };
    const matchedParties = {};
    const pinnedParties = {};
          // 고정 파티
      pinned.forEach((party, i) => {
        const members = party.map(p =>
          `<span class="role-${p.role==='딜러'?'dps':p.role==='힐러'?'heal':'tank'}">${p.nickname} (${p.job})</span>` + (p.note ? ` - [${p.note}]` : '')
        ).join(', ');
        html += `<div class="party-block fixed"><strong>🔒 고정 파티 ${i+1}</strong>: ${members}`;
        html += `<button class="inline-btn" onclick="addMemo('${key}',${i})">메모</button>`;
        html += `<button class="inline-btn" onclick="unpinParty('${key}',${i})">고정해제</button>`;
        // 메모 표시
        const memoText = (pinnedMemos[key] && pinnedMemos[key][i]) ? pinnedMemos[key][i] : '';
        html += `<div class="memo">${memoText}</div>`;
        html += `</div>`;
      });
      // 일반 파티
      unmatched.forEach((party, i) => {
        const members = party.map(p =>
          `<span class="role-${p.role==='딜러'?'dps':p.role==='힐러'?'heal':'tank'}">${p.nickname} (${p.job})</span>` + (p.note ? ` - [${p.note}]` : '')
        ).join(', ');
        html += `<div class="party-block"><strong>파티 ${i+1}</strong>: ${members}<button class="inline-btn" onclick="pinParty('${key}',${i})">고정</button><button class="inline-btn" onclick="deleteParty('${key}',${i})">❌</button></div>`;
      });
      box.innerHTML = html;
    }
    window.renderMatched = renderMatched = renderMatched;

    function pinParty(key,idx) { if (!pinnedParties[key]) pinnedParties[key] = [];
      const grp = matchedParties[key].splice(idx,1)[0];
      pinnedParties[key].push(grp);
      db.ref(`matchedParties/${key}`).set([...pinnedParties[key], ...matchedParties[key]]);
      renderMatched(key);
    } window.pinParty = pinParty;

    function unpinParty(key,idx) { const grp = pinnedParties[key].splice(idx,1)[0]; matchedParties[key].unshift(grp);
      db.ref(`matchedParties/${key}`).set([...pinnedParties[key], ...matchedParties[key]]);
      renderMatched(key);
    } window.unpinParty = unpinParty;

    function deleteParty(key,idx) { const p = matchedParties[key].splice(idx,1)[0]; p.forEach(m => db.ref(`parties/${key}/${m.id}`).set(m));
      db.ref(`matchedParties/${key}`).set([...pinnedParties[key], ...matchedParties[key]]);
      renderMatched(key);
    } window.deleteParty = deleteParty;

    function match(key,size) {
      const partiesRef = db.ref(`parties/${key}`), matchedRef = db.ref(`matchedParties/${key}`);
      if (matchedParties[key]) matchedParties[key].flat().forEach(m => db.ref(`parties/${key}/${m.id}`).set(m));
      matchedRef.set([])
        .then(() => partiesRef.once('value'))
        .then(snap => {
          let mems = snap.val() ? Object.entries(snap.val()).map(([id,v]) => normalize(v,id)) : [];
          const pinnedIds = new Set((pinnedParties[key] || []).flat().map(m => m.id));
          mems = mems.filter(p => !pinnedIds.has(p.id));
          shuffle(mems);
          const newMatched = [];
          while (mems.length >= size) {
            const group = [];
            const used = new Set();
            for (const p of mems) {
              if (group.length === size) break;
              if (!used.has(p.nickname)) {
                group.push(p);
                used.add(p.nickname);
              }
            }
            if (group.length < size) break;
            newMatched.push(group);
            mems = mems.filter(p => !used.has(p.nickname));
          }
          // 고정 파티와 동일한 그룹 제거
          const finalMatched = newMatched.filter(group => {
            const groupIds = new Set(group.map(m => m.id));
            return !(pinnedParties[key] || []).some(pinnedGrp => {
              const pinnedIdsSet = new Set(pinnedGrp.map(m => m.id));
              if (pinnedIdsSet.size !== groupIds.size) return false;
              for (const id of pinnedIdsSet) if (!groupIds.has(id)) return false;
              return true;
            });
          });
          matchedParties[key] = finalMatched;
          return matchedRef.set(finalMatched);
        })
        .then(() => partiesRef.once('value'))
        .then(() => Promise.all((matchedParties[key] || []).flat().map(p => db.ref(`parties/${key}/${p.id}`).remove())))
        .then(() => renderMatched(key))
        .catch(err => console.error(err));
    }
    window.match = match;

    Object.keys(dungeonConfigs).forEach(d => dungeonConfigs[d].difficulties.forEach(diff => {
      const k = `${d}_${diff}`;
      db.ref(`parties/${k}`).on('value', snap => {
        const list = snap.val() ? Object.entries(snap.val()).map(([id,v]) => normalize(v,id)) : [];
        renderSection(k, list);
      });
      db.ref(`matchedParties/${k}`).on('value', snap => {
        matchedParties[k] = snap.val() || [];
        renderMatched(k);
      });
    }));
  </script>
</body>
</html>
